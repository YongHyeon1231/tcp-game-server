# tcp-game-server

[내일 배움 캠프] 스파르타) Node.js 게임서버개발 주특기 플러스 + 2주차 강의에서 다뤄진 TCP 게임 서버 만들기

# 들어가 있는 내용

프로젝트 전체 구조부터 시작해서 패킷 구조 설계,
교환,
세션,
DB,
게임 및 유저 인스턴스 객체화,
인스턴스 관리,
상태 동기화,
레이턴시 관리,
레이턴시 마스킹

위의 내용이 여기에 들어가 있으니 가져다가 이것저것 만들어봅니다.

# 사용한 라이브러리들

npm init -y
npm install dotenv lodash long mysql2 protobufjs uuid
npm install -D nodemon prettier

# 중앙 집중식 관리

- 모든 환경 변수와 상수는 한 곳에서 관리, 다른 파일에서 동일한 값을 사용하여도 일관성을 유지
- 변경이 필요할 때 한 곳에서만 수정하면 됨
- 환경 변수, 상수의 직접 사용이 아니기때문에 코드가 명확해지는 효과
- 필요한 경우 개발, 테스트, 프로덕션 환경별로 다른 설정 사용 가능

# 소켓 이벤트 분리

- 이벤트를 구분해서 관리할 수 있습니다.
- 바이트 배열에서 패킷 헤더를 구분할 수 있습니다.
- 위의 것을 하기 위해서 소켓 이벤트들을 분리해줘야합니다.
- 이때 분리해서 각각의 소켓 이벤트들을 호출해 줄 때 '커링'이라는 기법을 사용하여 여러 인수를 받는 함수를 인수가 하나인 함수들의 연속으로 변환시켜줍니다.
- 바이트 배열을 분해하여 각 클라이언트마다 고유한 버퍼를 할당해주는 것 입니다.
- 그렇다면 socket 이벤트 중에서 데이터를 받는 이벤트가 'data' 이벤트 이기 때문에 우리의 데이터는 스트림을 통해 청크단위로 조금씩 전송받기 때문에 우리가 원하는 데이터가 들어올때까지 계속 대기하다가 원하는 데이터가 도착하면 처리해주면 됩니다.

# 프로토 파일 로드

(프로토 버퍼 파일은 패킷구조를 정의해주는 파일이다.)

- Protocol Buffers 형식의 파일을 서버나 클라이언트 애플리케이션에서 로드해 사용하는 것을 의미합니다.
- XML이나 JSON보다 데이터의 크기가 작고 빠르며, 이진 형식으로 처리.
- 데이터 구조를 명확히 정의하여 실수나 불일치 방지.
- 다양한 언어에서 동일한 데이터 구조로 사용할 수 있습니다.

# 패킷 파싱

(바이트 배열을 우리가 지정한 구조로 파싱하는 것이다.)

- 수신된 패킷을 헤더와 데이터로 나눕니다.
- 패킷 헤더에는 출발지와 IP 주소, 포트 번호, 프로토콜 정보 등 다양한 메타 데이터가 포함되어 있으며, 이를 해석하여 패킷의 목적을 확인합니다.
- 헤더를 통해 얻은 정보를 바탕으로, 데이터 부분을 프로토콜 규약에 따라 해석하여 응용 프로그램이 처리할 수 있는 데이터로 변환합니다.
- 패킷의 무결성을 검사하여 데이터 손상 여부나 에러 발생 여부를 확인하고, 이를 파악해 적절히 처리합니다.

# 핸들러

- 특정 요청을 처리하는 기능 단위
- 클라이언트가 서버에 보낸 요청을 받아서 필요한 작업을 수행하고 그 결과를 반환하는 역할을 합니다.

# 세션

- 서버와 클라이언트 간의 특정 기간 동안 유지되는 연결 상태를 말하며
- 주로 사용자의 인증 정보나 상태 정보를 관리하는 데 사용됩니다.
- 세션은 사용자가 로그인하여 서버에 접속한 이후부터 로그아웃하거나 연결이 끊어질 때까지의 상태를 추적하여 사용자 고유의 상태를 유지합니다.
- 사용자 식별: 세션을 통해 사용자가 웹사이트나 애플리케이션에 재접속했을 때도 동일한 사용자로 식별할 수 있습니다.
- 이를 위해 서버는 각 사용자에게 고유한 세션 ID를 할당하고 이를 통해 사용자를 구분합니다.
- 상태 유지: 세션을 사용하면 로그인 상태, 장바구니에 담긴 항목, 사용자 설정 등의 상태를 지속해서 유지할 수 있습니다.
- 세션 ID: 세션은 보통 서버에 저장되고, 서버는 클라이언트에게 세션 ID라는 고유 식별자를 세공합니다.
- 클라이언트는 세션 ID를 쿠키, URL 파라미터, 헤더 등을 통해 서버에 전달하고, 서버는 이 ID를 이용해 사용자의 세션 데이터를 조회합니다.
- 보안 관리: 세션은 민감한 사용자 정보를 포함할 수 있으므로, 세션 ID가 유출되면 보안 문제가 발생할 수 있습니다.
- 따라서 세션 관리에는 HTTPS, 세션 만료 시간, CSRF 방어 등 다양한 보안 조치가 필수적입니다.
- 저장소: 세션 정보는 일반적으로 메모리, 데이터베이스, Redis 같은 인메모리 데이터 저장소에 저장됩니다.
- 이를 통해 서버는 사용자가 언제 어디서 접속하더라도 일관된 사용자 경험을 제공 할 수 있습니다.

# 패킷 검증 추가

- 소프트웨어나 게임의 파일이 개발자가 의도한 대로 제대로 설치되었는지, 설치 과정에서 손상되거나 변조되지 않았는지를 확인합니다.
- 악성 코드나 해킹으로 인해 파일이 변조되지 않았는지 검증하여 보안을 강화합니다.
- MD5, SHA256 같은 해시 알고리즘을 사용하여 원본 파일과 다운로드된 파일의 해시값을 비교한다.
- 파일에 디지털 서명을 추가하여 배포된 파일이 신뢰할 수 있는 소스에서 온 것인지 확인한다.
- 패키지 내에 포함된 각 파일의 체크섬을 비교하여 파일의 변조 여부를 확인한다.

# 에러 핸들링

- 예상치 못한 상황에서 프로그램이 멈추지 않도록 해 사용자가 오류를 인지하거나 문제를 해결할 수 있게 합니다.
- 발생한 오류의 원인과 위치를 파악하여 이를 기록하거나, 사용자에게 알림으로써 문제 해결에 도움을 줍니다.
- 사용자가 프로그램을 사용하는 도중에 발생할 수 있는 오류 상황에서, 적절한 메시지를 제공해 불편함을 최소화할 수 있습니다.
- 구문 에러(Syntax Error): 코드 작성 시 문법에 맞지 않아서 발생하는 오류. 컴파일 단계에서 발생하며 프로그램 실행 전 수정이 필요합니다.
- 런타임 에러(Runtime Error): 프로그램 실행 중에 발생하는 오류. 예를 들어, 존재하지 않는 파일을 읽으려 하거나 0으로 나누는 경우 등이 있습니다.
- 로직 에러(Logic Error): 코드가 실행되지만, 개발자가 의도한 것과 다르게 동작하는 경우. 이 경우, 에러 메시지가 나타나지 않아 발견이 어려울 수 있습니다.

# DB 연동

1. 커넥션 풀 (Connection Pool)
   1. 데이터베이스와의 연결을 미리 여러 개 생성하여 풀에 저장한다.
   2. 필요할 때마다 재사용하여 성능을 향상
   3. 미리 생성된 연결을 사용함으로써 응답 시간 감소
2. docker를 이용해 mysql server 1개에 db 2개 연결

# DB 마이그레이션

- 새로운 기능 추가로 인해 스키마 변경이 필요할 때 (지금 우리 상황)
- 데이터베이스 성능 향상을 위해 구조를 최적화할 때
- 데이터베이스 시스템을 교체할 때 (예: MySQL에서 PostgreSQL로)

# 유저 데이터 저장

- 최초 접속시 유저 정보를 DB에 저장합니다.

# 객제치향 패턴

(체지향 패턴을 사용해서 유저, 게임 인스턴스를 생성한 뒤 세션에서 관리한다.)

- 장점
  - 코드 재사용성
  - 가독성 및 유지보수성
  - 데이터 캡슐화
  - 다형성
  - …
- 단점
  - 절차 지향 패턴보다 많은 메모리와 처리 시간이 소모될 가능성이 있다.
  - 복잡하다.
  - 러닝커브가 상대적으로 높다.

# 게임 로직 추가 (비지니스 로직 작성)

- 게임을 생성, 참가할 수 있다.
- 유저가 게임을 생성하면 게임ID가 발급이 됩니다. 그 ID를 사용해서 다른 유저들이 해당 게임방에 접속을 하게 됩니다. 그 이후 최대정원이 되면 자동으로 게임이 시작이 되고 유저들에게 게임 시작 알림이 가게됩니다.

# Latency

- 한 지점에서 다른 지점으로 이동하는 데 걸리는 시간
- 라운드 트립 레이턴시 (Round Trip Latency)
  - 라운드 트립 타임(RTT, Round Trip Time)
  - ‘핑(Ping)’ 명령어를 통해 측정됨
  - 10년 전쯤 롤은 로딩창에서 핑(RTT, RTL)을 볼 수 있었다. (문득 생각이…)
  - 네트워크 라운드 트립은 서버와 클라이언트 간에 데이터를 왕복하는 데 걸리는 시간입니다. 이는 레이턴시의 중요한 요소 중 하나입니다.
  - 게임에서 라운드 트립은 주로 서버에 요청을 보내고 응답을 받기까지 걸리는 시간을 측정하는 데 사용됩니다
- 추측항법(Dead Reckoning)
  - 레이턴시 마스킹(Latency Masking)
    - 네트워크 지연을 사용자가 느끼지 못하도록 숨기는 기술
    - 예측 및 보정, 보간, 평활화
  - 추측항법 (Dead Reckoning)
    - 예측 및 보정
    - 이미 지난 약간의 시간만큼 예측해서 데이터 전달
      - 레이턴시가 100ms 인 상황에서 속도가 1, 1초에 1번 패킷 전달의 경우
        - 1초 뒤 보낼 패킷은 1.1초에 도착을 하니 (거리 = 속력 x 시간) 공식에 따라서 1.1 x 1 만큼의 값을 전달
        - '거속시' 공식은 '속도'가 아닌 '속력'이기 때문에 이동 방향 마다 다른 계산이 필요
- 게임 서버 내에 게임 세션이 여러개 생성되고 유저들이 게임에 참여했습니다.
- 각 유저들의 라운드 트립 레이턴시를 측정해 서버에 기록합니다.
- 간단한 방법으로 평균으로 계산하는 것과 가장 높은 값을 사용하는 것이 있습니다.
- 이번 프로젝트에서는 가장 높은 값을 사용하도록 하겠습니다.
- 이는 평균값을 사용하는 것보다 안정적인 멀티플레이 동기화 환경을 제공할 수 있습니다.

# 라운드 트립 레이턴시 측정 (사실상 핑)

(유저 클래스의 메서드로 클라이언트와 서버간의 RTT를 측정, 저장합니다.)

- 네트워크 라운드 트립 (RTT): 클라이언트에서 서버로 요청을 보내고 응답을 받기까지 걸리는 전체 왕복 시간.
- 레이턴시 (Latency): 사용자의 입력이 서버에 도달하고 반응이 일어나는 지연 시간으로, 네트워크 지연을 포함한 더 넓은 범위의 시간을 의미합니다.
- 게임에서 레이턴시는 게임 내에서 느끼는 반응 속도로, 빠른 응답을 위해서는 네트워크 지연, 서버 처리 시간, 클라이언트의 그래픽 렌더링 속도 등 다양한 요소의 최적화가 필요합니다.

# 인터벌 매니저 추가

(유저가 보낸 핑은 일정한 주기를 가지고 계속해서 측정해야합니다.
게임 인스턴스에는 유저들이 속해있고 각 유저들의 인터벌(핑)을 관리하는 매니저를 만들어 주기로 합니다.
필요하다면 유저의 핑 뿐만 아니라 게임내의 모든 인터벌을 관리하도록 할 수 있습니다.)

- 작업 예약: 특정 시간 간격으로 실행할 작업을 예약합니다.
- 작업 관리: 인터벌 작업을 추가, 삭제, 일시 정지하거나 재개하는 기능을 제공합니다.
- 리소스 관리: 작업이 중복되거나 불필요하게 반복되는 것을 방지하여 시스템 자원을 효율적으로 사용합니다.
- 에러 처리 및 상태 확인: 작업 실행 중 오류가 발생하면 이를 처리하며, 현재 인터벌 작업의 상태를 확인할 수 있도록 합니다.

# 상태 동기화 (위치 정보 교환)

(정보를 전달함으로써 플레이어들의 상태를 일관되게 유지합니다.)

- 상태 동기화는 분산 시스템이나 멀티플레이어 게임, 클라이언트-서버 환경에서 여러 클라이언트와 서버 간에 동일한 상태를 유지하는 것을 의미합니다. 상태 동기화가 이루어지면, 모든 클라이언트와 서버는 특정 시점에서 동일한 데이터나 정보를 갖게 되어 일관된 상태로 동작할 수 있습니다.
- 지연(Latency): 네트워크 지연으로 인해 일부 클라이언트의 상태 업데이트가 느려질 수 있습니다. 이를 보정하기 위해 예측(predictive) 모델을 사용할 수 있습니다.
- 일관성 유지(Consistency): 상태를 변경하는 여러 사용자가 있을 때, 일관성을 유지하기 위한 충돌 해결(Conflict Resolution) 방법이 필요합니다.
- 성능 최적화: 동기화 주기가 짧을수록 네트워크 부하가 커지므로, 최적의 주기와 전송량을 유지하도록 해야 합니다.
