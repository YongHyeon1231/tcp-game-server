# tcp-game-server

[내일 배움 캠프] 스파르타) Node.js 게임서버개발 주특기 플러스 + 2주차 강의에서 다뤄진 TCP 게임 서버 만들기

# 들어가 있는 내용

프로젝트 전체 구조부터 시작해서 패킷 구조 설계,
교환,
세션,
DB,
게임 및 유저 인스턴스 객체화,
인스턴스 관리,
상태 동기화,
레이턴시 관리,
레이턴시 마스킹

위의 내용이 여기에 들어가 있으니 가져다가 이것저것 만들어봅니다.

# 사용한 라이브러리들

npm init -y
npm install dotenv lodash long mysql2 protobufjs uuid
npm install -D nodemon prettier

# 중앙 집중식 관리

- 모든 환경 변수와 상수는 한 곳에서 관리, 다른 파일에서 동일한 값을 사용하여도 일관성을 유지
- 변경이 필요할 때 한 곳에서만 수정하면 됨
- 환경 변수, 상수의 직접 사용이 아니기때문에 코드가 명확해지는 효과
- 필요한 경우 개발, 테스트, 프로덕션 환경별로 다른 설정 사용 가능

# 소켓 이벤트 분리

- 이벤트를 구분해서 관리할 수 있습니다.
- 바이트 배열에서 패킷 헤더를 구분할 수 있습니다.
- 위의 것을 하기 위해서 소켓 이벤트들을 분리해줘야합니다.
- 이때 분리해서 각각의 소켓 이벤트들을 호출해 줄 때 '커링'이라는 기법을 사용하여 여러 인수를 받는 함수를 인수가 하나인 함수들의 연속으로 변환시켜줍니다.
- 바이트 배열을 분해하여 각 클라이언트마다 고유한 버퍼를 할당해주는 것 입니다.
- 그렇다면 socket 이벤트 중에서 데이터를 받는 이벤트가 'data' 이벤트 이기 때문에 우리의 데이터는 스트림을 통해 청크단위로 조금씩 전송받기 때문에 우리가 원하는 데이터가 들어올때까지 계속 대기하다가 원하는 데이터가 도착하면 처리해주면 됩니다.

# 프로토 파일 로드

(프로토 버퍼 파일은 패킷구조를 정의해주는 파일이다.)

- Protocol Buffers 형식의 파일을 서버나 클라이언트 애플리케이션에서 로드해 사용하는 것을 의미합니다.
- XML이나 JSON보다 데이터의 크기가 작고 빠르며, 이진 형식으로 처리.
- 데이터 구조를 명확히 정의하여 실수나 불일치 방지.
- 다양한 언어에서 동일한 데이터 구조로 사용할 수 있습니다.

# 패킷 파싱

(바이트 배열을 우리가 지정한 구조로 파싱하는 것이다.)

- 수신된 패킷을 헤더와 데이터로 나눕니다.
- 패킷 헤더에는 출발지와 IP 주소, 포트 번호, 프로토콜 정보 등 다양한 메타 데이터가 포함되어 있으며, 이를 해석하여 패킷의 목적을 확인합니다.
- 헤더를 통해 얻은 정보를 바탕으로, 데이터 부분을 프로토콜 규약에 따라 해석하여 응용 프로그램이 처리할 수 있는 데이터로 변환합니다.
- 패킷의 무결성을 검사하여 데이터 손상 여부나 에러 발생 여부를 확인하고, 이를 파악해 적절히 처리합니다.

# 핸들러

- 특정 요청을 처리하는 기능 단위
- 클라이언트가 서버에 보낸 요청을 받아서 필요한 작업을 수행하고 그 결과를 반환하는 역할을 합니다.

# 세션

- 서버와 클라이언트 간의 특정 기간 동안 유지되는 연결 상태를 말하며
- 주로 사용자의 인증 정보나 상태 정보를 관리하는 데 사용됩니다.
- 세션은 사용자가 로그인하여 서버에 접속한 이후부터 로그아웃하거나 연결이 끊어질 때까지의 상태를 추적하여 사용자 고유의 상태를 유지합니다.
- 사용자 식별: 세션을 통해 사용자가 웹사이트나 애플리케이션에 재접속했을 때도 동일한 사용자로 식별할 수 있습니다.
- 이를 위해 서버는 각 사용자에게 고유한 세션 ID를 할당하고 이를 통해 사용자를 구분합니다.
- 상태 유지: 세션을 사용하면 로그인 상태, 장바구니에 담긴 항목, 사용자 설정 등의 상태를 지속해서 유지할 수 있습니다.
- 세션 ID: 세션은 보통 서버에 저장되고, 서버는 클라이언트에게 세션 ID라는 고유 식별자를 세공합니다.
- 클라이언트는 세션 ID를 쿠키, URL 파라미터, 헤더 등을 통해 서버에 전달하고, 서버는 이 ID를 이용해 사용자의 세션 데이터를 조회합니다.
- 보안 관리: 세션은 민감한 사용자 정보를 포함할 수 있으므로, 세션 ID가 유출되면 보안 문제가 발생할 수 있습니다.
- 따라서 세션 관리에는 HTTPS, 세션 만료 시간, CSRF 방어 등 다양한 보안 조치가 필수적입니다.
- 저장소: 세션 정보는 일반적으로 메모리, 데이터베이스, Redis 같은 인메모리 데이터 저장소에 저장됩니다.
- 이를 통해 서버는 사용자가 언제 어디서 접속하더라도 일관된 사용자 경험을 제공 할 수 있습니다.

# 패킷 검증 추가

- 소프트웨어나 게임의 파일이 개발자가 의도한 대로 제대로 설치되었는지, 설치 과정에서 손상되거나 변조되지 않았는지를 확인합니다.
- 악성 코드나 해킹으로 인해 파일이 변조되지 않았는지 검증하여 보안을 강화합니다.
- MD5, SHA256 같은 해시 알고리즘을 사용하여 원본 파일과 다운로드된 파일의 해시값을 비교한다.
- 파일에 디지털 서명을 추가하여 배포된 파일이 신뢰할 수 있는 소스에서 온 것인지 확인한다.
- 패키지 내에 포함된 각 파일의 체크섬을 비교하여 파일의 변조 여부를 확인한다.

# 에러 핸들링

- 예상치 못한 상황에서 프로그램이 멈추지 않도록 해 사용자가 오류를 인지하거나 문제를 해결할 수 있게 합니다.
- 발생한 오류의 원인과 위치를 파악하여 이를 기록하거나, 사용자에게 알림으로써 문제 해결에 도움을 줍니다.
- 사용자가 프로그램을 사용하는 도중에 발생할 수 있는 오류 상황에서, 적절한 메시지를 제공해 불편함을 최소화할 수 있습니다.
- 구문 에러(Syntax Error): 코드 작성 시 문법에 맞지 않아서 발생하는 오류. 컴파일 단계에서 발생하며 프로그램 실행 전 수정이 필요합니다.
- 런타임 에러(Runtime Error): 프로그램 실행 중에 발생하는 오류. 예를 들어, 존재하지 않는 파일을 읽으려 하거나 0으로 나누는 경우 등이 있습니다.
- 로직 에러(Logic Error): 코드가 실행되지만, 개발자가 의도한 것과 다르게 동작하는 경우. 이 경우, 에러 메시지가 나타나지 않아 발견이 어려울 수 있습니다.
